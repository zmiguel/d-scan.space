name: build-dev

on:
  push:
    branches: ['main', 'preview', 'dev']
    tags: ['v*.*.*']

env:
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io
  # github.repository as <account>/<repo>
  IMAGE_NAME: zmiguel/d-scan-space

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      build_matrix: ${{ steps.set-matrix.outputs.build_matrix }}
      merge_matrix: ${{ steps.set-matrix.outputs.merge_matrix }}
      should_run: ${{ steps.set-matrix.outputs.should_run }}
    steps:
      - uses: actions/checkout@v4

      - uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            main:
              - 'src/**'
              - 'static/**'
              - 'drizzle/**'
              - 'Dockerfile'
              - 'package.json'
              - '*.config.js'
              - '.github/workflows/build-dev.yml'
            updater:
              - 'workers/updater/**'
              - 'src/lib/database/**'
              - 'src/lib/server/**'
              - 'src/lib/logger.js'
              - 'drizzle/**'
              - '.github/workflows/build-dev.yml'

      - id: set-matrix
        run: |
          BUILD_INCLUDE="[]"
          MERGE_INCLUDE="[]"
          SHOULD_RUN="false"

          if [[ "${GITHUB_REF}" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            SHOULD_RUN="true"
            BUILD_INCLUDE=$(echo $BUILD_INCLUDE | jq -c '. + [
              {platform: "linux/amd64", runner: "ubuntu-latest", context: ".", image_suffix: "", dockerfile: "Dockerfile", image_key: "main"},
              {platform: "linux/arm64", runner: "ubuntu-24.04-arm", context: ".", image_suffix: "", dockerfile: "Dockerfile", image_key: "main"},
              {platform: "linux/amd64", runner: "ubuntu-latest", context: ".", image_suffix: "-updater", dockerfile: "workers/updater/Dockerfile", image_key: "updater"},
              {platform: "linux/arm64", runner: "ubuntu-24.04-arm", context: ".", image_suffix: "-updater", dockerfile: "workers/updater/Dockerfile", image_key: "updater"}
            ]')
            MERGE_INCLUDE=$(echo $MERGE_INCLUDE | jq -c '. + [
              {image_suffix: "", image_key: "main"},
              {image_suffix: "-updater", image_key: "updater"}
            ]')
          else

          if [[ "${{ steps.changes.outputs.main }}" == "true" ]]; then
            SHOULD_RUN="true"
            BUILD_INCLUDE=$(echo $BUILD_INCLUDE | jq -c '. + [
              {platform: "linux/amd64", runner: "ubuntu-latest", context: ".", image_suffix: "", dockerfile: "Dockerfile", image_key: "main"},
              {platform: "linux/arm64", runner: "ubuntu-24.04-arm", context: ".", image_suffix: "", dockerfile: "Dockerfile", image_key: "main"}
            ]')
            MERGE_INCLUDE=$(echo $MERGE_INCLUDE | jq -c '. + [
              {image_suffix: "", image_key: "main"}
            ]')
          fi

          if [[ "${{ steps.changes.outputs.updater }}" == "true" ]]; then
            SHOULD_RUN="true"
            BUILD_INCLUDE=$(echo $BUILD_INCLUDE | jq -c '. + [
              {platform: "linux/amd64", runner: "ubuntu-latest", context: ".", image_suffix: "-updater", dockerfile: "workers/updater/Dockerfile", image_key: "updater"},
              {platform: "linux/arm64", runner: "ubuntu-24.04-arm", context: ".", image_suffix: "-updater", dockerfile: "workers/updater/Dockerfile", image_key: "updater"}
            ]')
            MERGE_INCLUDE=$(echo $MERGE_INCLUDE | jq -c '. + [
              {image_suffix: "-updater", image_key: "updater"}
            ]')
          fi

          fi

          echo "build_matrix={\"include\":$BUILD_INCLUDE}" >> $GITHUB_OUTPUT
          echo "merge_matrix={\"include\":$MERGE_INCLUDE}" >> $GITHUB_OUTPUT
          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT

  build:
    needs: check-changes
    if: needs.check-changes.outputs.should_run == 'true'
    strategy:
      matrix: ${{ fromJson(needs.check-changes.outputs.build_matrix) }}

    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
      # This is used to complete the identity challenge
      # with sigstore/fulcio when running outside of PRs.
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install the cosign tool except on PR
      # https://github.com/sigstore/cosign-installer
      - name: Install cosign
        if: github.event_name != 'pull_request'
        uses: sigstore/cosign-installer@v3.9.1 #v2.6.0
        with:
          cosign-release: 'v2.5.2'

      # Workaround: https://github.com/docker/build-push-action/issues/461
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v3

      # Login against a Docker registry except on PR
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels) for Docker
      # https://github.com/docker/metadata-action
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}${{ matrix.image_suffix }}
          tags: |
            type=ref,event=branch
            type=semver,pattern=v{{version}}
            type=semver,pattern=v{{major}}.{{minor}}
            type=semver,pattern=v{{major}}
            type=raw,value=latest,enable=${{ startsWith(github.ref, 'refs/tags/v') }}

      # Build and push Docker image for specific platform
      # https://github.com/docker/build-push-action
      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: ${{ matrix.platform }}
          provenance: mode=max
          sbom: true
          cache-from: type=gha,scope=build-${{ matrix.image_key }}-${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=build-${{ matrix.image_key }}-${{ matrix.platform }}
          outputs: type=image,name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}${{ matrix.image_suffix }},push-by-digest=${{ github.event_name != 'pull_request' }},name-canonical=true,push=${{ github.event_name != 'pull_request' }}

      # Export digest for manifest creation
      - name: Export digest
        if: github.event_name != 'pull_request'
        run: |
          mkdir -p /tmp/digests
          digest="${{ steps.build-and-push.outputs.digest }}"
          touch "/tmp/digests/${digest#sha256:}"

      # Upload digest artifacts
      - name: Upload digest
        if: github.event_name != 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.image_key }}-${{ matrix.platform == 'linux/amd64' && 'amd64' || 'arm64' }}
          path: /tmp/digests/*
          if-no-files-found: error
          retention-days: 1

  merge:
    runs-on: ubuntu-latest
    needs: [check-changes, build]
    if: needs.check-changes.outputs.should_run == 'true' && github.event_name != 'pull_request'
    strategy:
      matrix: ${{ fromJson(needs.check-changes.outputs.merge_matrix) }}
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Install the cosign tool
      - name: Install cosign
        uses: sigstore/cosign-installer@v3.9.1
        with:
          cosign-release: 'v2.5.2'

      # Setup Docker buildx
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v3

      # Login against a Docker registry
      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata (tags, labels) for Docker
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}${{ matrix.image_suffix }}
          tags: |
            type=ref,event=branch
            type=semver,pattern=v{{version}}
            type=semver,pattern=v{{major}}.{{minor}}
            type=semver,pattern=v{{major}}
            type=raw,value=latest,enable=${{ startsWith(github.ref, 'refs/tags/v') }}

      # Download digest artifacts
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests
          pattern: digests-${{ matrix.image_key }}-*
          merge-multiple: true

      # Create and push multi-platform manifest
      - name: Create multi-platform manifest
        working-directory: /tmp/digests
        run: |
          TAG_ARGS=$(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          docker buildx imagetools create ${TAG_ARGS} \
            $(printf '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}${{ matrix.image_suffix }}@sha256:%s ' *)

          # Get the digest of the created manifest (use primary tag to avoid newline issues)
          PRIMARY_TAG=$(jq -r '.tags[0]' <<< "$DOCKER_METADATA_OUTPUT_JSON")
          DIGEST=$(docker buildx imagetools inspect "$PRIMARY_TAG" --raw | sha256sum | cut -d' ' -f1)
          echo "DIGEST=sha256:$DIGEST" >> $GITHUB_OUTPUT
        id: manifest

      # Sign the multi-platform manifest
      - name: Sign the multi-platform manifest
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
          DIGEST: ${{ steps.manifest.outputs.DIGEST }}
        run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
